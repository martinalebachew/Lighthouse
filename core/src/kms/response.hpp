// response.hpp
// (C) Martin Alebachew, 2023

/*
This file defines the KMS Response struct.
This file includes modified code from vlmcsd/kms.h by Wind4.
*/

#pragma once
#include "crypto.hpp"
#include "hmac.hpp"
#include "request.hpp"
#include "sha256.hpp"
#include "winapi_types.hpp"
#include <cstdint>
#include <vector>

static const BYTE DefaultHwId[8] = {0x3A, 0x1C, 0x04, 0x96, 0x00, 0xB6, 0x00, 0x76};

namespace KMS {
struct Response {
  /* NOTE
  Modifying the properties below may break the casting algorithm.
  Adjust it accordingly.
  */

  uint32_t bodyLength1;
  uint32_t _ = 131072; // TODO: Figure out the purpose of this field
  uint32_t bodyLength2;

  // UNENCRYPTED
  VERSION RawVersion; // Minor and major version, unencrypted
  BYTE IV[16];        // Initialization vector generated by the client

  // ENCRYPTED, AES CBC 128-bits key, PKCS7
  VERSION Version;            // Minor and major version
  DWORD PIDSize;              // Size of PIDData in bytes
  WCHAR KmsPID[64];           // [Variable size] ePID (must include terminating zero)
  GUID CMID;                  // Client machine id. Must be the same as in request
  FILETIME ClientTime;        // Current client time. Must be the same as in request
  DWORD Count;                // Current activated machines. KMS server counts up to N_Policy << 1 then stops
  DWORD VLActivationInterval; // Time in minutes when clients should retry activation if it was unsuccessful (default 2 hours)
  DWORD VLRenewalInterval;    // Time in minutes when clients should renew KMS activation (default 7 days)

  BYTE RandomXoredIVs[16]; // Random salt ^ decrypted Request IV
  BYTE Hash[32];           // SHA256 of Random salt used in RandomXoredIVs
  BYTE HwId[8];            // HwId from the KMS server
  BYTE XoredIVs[16];       // Decrypted Request IV
  BYTE HMAC[16];           // V6 Hmac (low 16 bytes only)

  // 16-octet alignment padding might be present here, required for encryption
  // 4 bytes error code should be present here
  // Both are added in the encrypted buffer

  Response(KMS::Request &request) {
    memcpy(IV, &request.IV, 16); // Use request IV for response
    Version = request.Version;
    RawVersion = request.RawVersion;

    // TODO: Generate PID values
    PIDSize = 2 * 49;
    byte pidexample[] = {
      0x35, 0x00, 0x35, 0x00, 0x30, 0x00, 0x34, 0x00, 0x31, 0x00, 0x2d, 0x00, 0x30, 0x00,
      0x30, 0x00, 0x32, 0x00, 0x30, 0x00, 0x36, 0x00, 0x2d, 0x00, 0x35, 0x00, 0x35, 0x00,
      0x35, 0x00, 0x2d, 0x00, 0x36, 0x00, 0x35, 0x00, 0x37, 0x00, 0x35, 0x00, 0x33, 0x00,
      0x30, 0x00, 0x2d, 0x00, 0x30, 0x00, 0x33, 0x00, 0x2d, 0x00, 0x36, 0x00, 0x31, 0x00,
      0x35, 0x00, 0x36, 0x00, 0x2d, 0x00, 0x37, 0x00, 0x36, 0x00, 0x30, 0x00, 0x31, 0x00,
      0x2e, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x2d, 0x00, 0x32, 0x00,
      0x31, 0x00, 0x33, 0x00, 0x32, 0x00, 0x30, 0x00, 0x31, 0x00, 0x39, 0x00, 0x00, 0x00
    };
    memcpy(KmsPID, pidexample, sizeof(pidexample));

    CMID = request.CMID;             // This value is set by the client
    ClientTime = request.ClientTime; // This value is set by the client

    Count = request.N_Policy << 1;
    VLActivationInterval = 120;
    VLRenewalInterval = 10080;
  }

  std::vector<byte> toEncryptedBuffer() {
    // Copy the response struct to a buffer
    size_t bufferSize = sizeof(Response) - sizeof(KmsPID) + PIDSize;
    std::vector<byte> buffer(bufferSize);

    memcpy(buffer.data(), this, offsetof(Response, KmsPID) + PIDSize);
    memcpy(
      buffer.data() + offsetof(Response, KmsPID) + PIDSize, &CMID,
      sizeof(Response) - offsetof(Response, CMID)
    );

    // Calculate the size of the encrypted data in the buffer and the required padding
    size_t encryptSize = sizeof(Response) - offsetof(Response, IV) - sizeof(KmsPID) + PIDSize;
    size_t encryptPadding = 16 - (encryptSize % 16);

    // Add the padding to the buffer
    bufferSize += encryptPadding;
    buffer.resize(bufferSize);

    { // This scope marks EOL of the temporary pointers
      // Create temnporary pointers to the buffer
      Response* bufferStart = (Response*)buffer.data();
      byte* bufferIV = bufferStart->IV;

      byte* bufferEnd = buffer.data() + buffer.size() - encryptPadding;
      byte* bufferRandomXoredIVs =
        bufferEnd - (sizeof(Response) - offsetof(Response, RandomXoredIVs));
      byte* bufferHash = bufferRandomXoredIVs + sizeof(RandomXoredIVs);
      byte* bufferHwId = bufferHash + sizeof(Hash);
      byte* bufferXoredIVs = bufferHwId + sizeof(HwId);

      // Get random salt and SHA256 it
      get16RandomBytes(bufferRandomXoredIVs);
      Sha256(bufferRandomXoredIVs, sizeof(RandomXoredIVs), bufferHash);

      // Xor Random bytes with decrypted request IV
      XorBlock(IV, bufferRandomXoredIVs);

      // Copy decrypted request IV to buffer
      memcpy(bufferXoredIVs, IV, 16);

      // pre-fill with default HwId
      memcpy(bufferHwId, DefaultHwId, sizeof(HwId));

      // Generate random IV for encryption
      get16RandomBytes(bufferIV);

      // Generate HMAC
      if (!CreateV6Hmac(bufferIV, encryptSize, 0))
        throw std::runtime_error("HMAC creation failed.");

      // Encrypt the buffer
      AesCtx aesCtx;
      AesInitKey(&aesCtx, KeyV6);
      AesEncryptCbc(&aesCtx, bufferIV, &encryptSize);
    }

    // Add error code and set to zero to signal success
    buffer.resize(buffer.size() + 4);
    memset(buffer.data() + buffer.size() - 4, 0, 4);

    // Set the body length properties in the buffer
    Response* bufferStart = (Response*)buffer.data();
    bufferStart->bodyLength1 = encryptSize + 4;
    bufferStart->bodyLength2 = bufferStart->bodyLength1;

    return buffer;
  }
} __attribute__((packed)); // Disabling compiler alignment in favor of RPC alignment
} // namespace KMS
